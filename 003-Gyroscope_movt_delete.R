rm(list=ls())
#------------------------------ FUNCTIONS FOR USE IN MAIN PROGRAM------------------------------#
EEG_Gyro_Decorrelator<-function(SingleUser_data,
                                windowSize=128,
                                corr_cutoff=1,
                                NumOfChannelCorrelated=13,
				                        EEG_ix=c(2:15),
				                        Gyro_ix=c(16:17),
                                verbose=TRUE){
  eeg_ch<-SingleUser_data[,EEG_ix]
  gyro_data<-SingleUser_data[,Gyro_ix]
  gyro_xyvec<-sqrt((gyro_data[,1]^2+gyro_data[,2]^2))  
  if(verbose){message(paste("Correlation b/w EEG and Gyro in window size ",windowSize))}

# Below, you get correlations for sliding windows across each EEG channel compared to the gyroscope signal   
# Windows are sized by Fs so total signal length divided by Fs gives total number of correlation coefficients
# that will be calculated for the input data.

All_eeg_channel_corr<-apply(eeg_ch,2,function(eeg_ch1){ 
                                eeg_gyro2<-cbind(eeg_ch1,gyro_xyvec)
                                start_indices<-seq(1,(nrow(eeg_gyro2)-windowSize),by=windowSize)
                                end_indices<-start_indices+(windowSize-1)
                                indices<-cbind(start_indices,end_indices)
                                corr_windowed<-apply(indices,1,function(ix)
                                  {
                                  sliding_window<-eeg_gyro2[ix[1]:ix[2],]
                                  corr_eeg1chGyroXY<-cor(sliding_window[,1],sliding_window[,2])
                                  return(corr_eeg1chGyroXY)
                                  })
                                return(corr_windowed)
                                })

message(paste("Determining correlations that cross cut-off for more than",NumOfChannelCorrelated,"channels"))
# If more than N channels (where N is a significant fraction of the total channels) are correlated with the gyroscope for a window, it is likely that the signal observed in 
# the EEG channel may have been generated by movement artifacts.
 
# The previous apply loop creates a matrix of correlation co-efficients with columns corresponding to each channel
# and rows corresponding to the correlation coefficient calculated for each sliding window.

# Finding the row index of the correlation coefficients crossing the cut-off value for more than NumOfChannelCorrelated
correlated_row_indices_length<-apply(All_eeg_channel_corr,1,function(cor_vec){length(which(abs(cor_vec)>corr_cutoff))})
outlier_windows<-which(correlated_row_indices_length>NumOfChannelCorrelated)

# Recalculating the indices for the sliding window because they don't exist outside the scope of the function in the
# apply iterator
start_indices<-seq(1,(nrow(eeg_ch)-windowSize),by=windowSize)
end_indices<-start_indices+(windowSize-1)
indices<-cbind(start_indices,end_indices)

message(paste("Eliminating EEG windows with correlation greater than",corr_cutoff,"with gyroscope signal"))
if(length(outlier_windows)!=0){
filtered_indices<-indices[-c(outlier_windows),]
}else{
 filtered_indices<-indices 
}
eeg_all_ch_filtered<-apply(filtered_indices,1,function(x){return(eeg_ch[x[1]:x[2],])})
eeg_all_ch_filtered_mat<-plyr::ldply(eeg_all_ch_filtered)
signal_loss_perc<-round((1-(nrow(eeg_all_ch_filtered_mat)/nrow(SingleUser_data)))*100,2)
message(paste("Returning reconstructed signal with timebase loss of ",signal_loss_perc," %"))
return(eeg_all_ch_filtered_mat)
}


#---------------------------------------------------------------------------------------------#
SignalQuality_Plot<-function(SingleUser_data,UserName){
CQ_score_table<-apply(SingleUser_data[,18:31],2,function(x){table(x)})
#sum(CQ_score_table[[1]])
if(is.vector(CQ_score_table)==TRUE && is.list(CQ_score_table)==FALSE){
  CQ_score_table<-matrix(CQ_score_table,ncol=1)
  label<-unique(unlist(unique(as.vector(SingleUser_data[,18:31]))))
  
  if(length(label)==1){
    colnames(CQ_score_table)<-label 
    }
  message("CQ was uniformly valued, returned a vector")
  }

if(is.list(CQ_score_table)==TRUE){
  CQ_came_as_matrix=FALSE
  CQ_score_norm<-lapply(CQ_score_table,function(x){(x/sum(x,na.rm = TRUE))*100})  
  CQ_range<-as.character(c(0:4))
  
  for(i in 1:length(CQ_score_norm)){
    current_scores<-names(CQ_score_norm[[i]])
    missing<-setdiff(CQ_range,current_scores)
    
    if(length(missing)>0)
    {
      CQ_score_norm[[i]]<-c(CQ_score_norm[[i]],rep(0,length(missing)))
      names(CQ_score_norm[[i]])[which(CQ_score_norm[[i]]==0)]<-missing
      CQ_score_norm[[i]]<-CQ_score_norm[[i]][order(names(CQ_score_norm[[i]]))]
    }
    } # end of for loop
  message("Non uniform: all CQ scores were not observed, added scores not observed at 0%")
  CQ_df<-plyr::ldply(CQ_score_norm)
  # CQ_df$.id<-colnames(SingleUser_data[,18:31])
  }

if(is.matrix(CQ_score_table)==TRUE && is.list(CQ_score_table)==FALSE){
  if(ncol(CQ_score_table)>1){
  message("All CQ Scores were observed,returned matrix")
  CQ_came_as_matrix=TRUE
  CQ_score_norm<-apply(CQ_score_table,2,function(x){(x/sum(x))*100})
  CQ_df<-data.frame(t(CQ_score_norm))
  CQ_df$.id<-colnames(SingleUser_data[,18:31])
  }
  
  if(ncol(CQ_score_table)==1)
    {
    message("Only 1 type of CQ score")
    CQ_score_norm<-apply(CQ_score_table,1,function(x){(x/sum(x))*100})
    CQ_df<-data.frame(CQ_score_norm)
    CQ_df$.id<-colnames(SingleUser_data[,18:31])
    }
  #message()
  }

  
#if(is.matrix(CQ_score_norm)!=TRUE){
#  CQ_df<-plyr::ldply(CQ_score_norm)
 # CQ_df$.id<-colnames(SingleUser_data[,18:31])
  
 # if(is.vector(CQ_score_norm)==TRUE && is.list(CQ_score_norm)==FALSE)
#      {
#      CQ_score_norm2<-matrix(CQ_score_norm,ncol=1)
#      rownames(CQ_score_norm2)<-colnames(SingleUser_data[,18:31])
 #     colnames(CQ_score_norm2)<-as.character(label)
    #CQ_score_norm<-t(CQ_score_norm)
#      CQ_df<-data.frame(CQ_score_norm2)
#      CQ_df$.id<-colnames(SingleUser_data[,18:31])
#      }
#    }

#CQ_score_norm

#CQ_df
CQ_df_melted<-reshape2::melt(CQ_df)
#UserName=SubjectNames[i]
require(ggplot2)
ggp<-ggplot(CQ_df_melted, aes(fill=variable, y=value, x=.id)) + 
  geom_bar(position="stack", stat="identity") +
  ggtitle(label = UserName)+
  xlab("Electrode")+
  ylab("Percentage")+
  labs(fill="Signal Quality")

  
print(ggp)
}
#------------------------ END OF FUNCTION DEFINITION------------------------------------------#

processedFileList<-list.files(path = "./3_EEG_GyroXY/",pattern="EEG_Gyro")
SubjectNames<-unlist(lapply(strsplit(processedFileList,split = "_"),function(x){x[1]}))
dir.create("4_EEG_GyroRemoved")
dir.create("016_SignalQualityPlots")
for(i in 1:length(processedFileList))
{
SingleUser_data<-read.table(file=paste("./3_EEG_GyroXY/",processedFileList[i],sep=""), header=TRUE,sep=",",stringsAsFactors=FALSE)
message(paste(i,SubjectNames[i],sep=" "))
SUD_filtered<-EEG_Gyro_Decorrelator(SingleUser_data = SingleUser_data)
write.table(x = SUD_filtered,file = paste("./4_EEG_GyroRemoved/",SubjectNames[i],"_gyroRemoved_",".csv",sep=""), sep=",", quote = FALSE,row.names = FALSE)
}
gc()

pdf("./003_SignalQualityPlots/ConnectionQuality.pdf",width=13,height = 9)
for(i in 1:length(processedFileList))
{
  SingleUser_data<-read.table(file=paste("./3_EEG_GyroXY/",processedFileList[i],sep=""), header=TRUE,sep=",",stringsAsFactors=FALSE)
  SignalQuality_Plot(SingleUser_data = SingleUser_data,UserName = SubjectNames[i])
  
}
dev.off()


